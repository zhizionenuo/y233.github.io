<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="qwq">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="y233" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        状态压缩｜欢迎来到希望学院
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2022/12/18/状态压缩/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/blog-style.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">

<meta name="generator" content="Hexo 6.2.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

<style>

    header.intro-header {
        background-image: url('https://cdn.luogu.com.cn/upload/image_hosting/pfpyx9eu.png')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    y233
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            
                            <a href="/tags/notes/">notes</a>
                            

                        </li>
							
						
                    
                        
							
                        <li>
                            
                                <a href="/tags/">tags</a>
                            

                        </li>
							
						
                    
                        
							
                        <li>
                            
                            <a href="/tags/逝月杂谈/">逝月杂谈</a>
                            

                        </li>
							
						
                    
                        
							
                        <li>
                            
                            <a href="/tags/题解/">题解</a>
                            

                        </li>
							
						
                    
                        
							
                        <li>
                            
                            <a href="/tags/随笔小说/">随笔小说</a>
                            

                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="https://cdn.luogu.com.cn/upload/image_hosting/ve77vglv.png">


<style>
    
    header.intro-header {
        background-image: url('https://cdn.luogu.com.cn/upload/image_hosting/ve77vglv.png')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>状态压缩</h1>

                    

                    
                    <span class="   ">
                         作者 y233
                        <span>
                          日期 2022/12/18
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/notes"
                           title="notes">notes</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            状态压缩
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="例题-1-POJ-2923"><a href="#例题-1-POJ-2923" class="headerlink" title="例题 1 POJ 2923"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-2923">例题 1 POJ 2923</a></h2><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意:"></a>简述题意:</h2><p>两辆车$n(1\le n\le10)$个物品，每个物品有体积$(1\le v\le 100)$，两辆车也有体积 $(1\le v_1,v_2\le 100)$， 要求把物品全部运走最少需要多少次 每次每辆车运送的物体总体积不得大于车的体积。</p>
<hr>
<p>Input:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6 12 13</span><br><span class="line">3 9 13 3 10 11</span><br><span class="line">7 1 100</span><br><span class="line">1 2 33 50 50 67 98</span><br></pre></td></tr></table></figure><br>Output:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Scenario #2:</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>显然 $n\le 10$ 是跪着求我们用状压了。</p>
<p>所以咱们正经点，上手状压。</p>
<p>令 $dp_i$ 表示状态为 i 时最少次数</p>
<p>老规矩，我们先枚举出每一个可能的状态。</p>
<p>然后 dp 。</p>
<p>只要要求两个状态之间的转移中没有重合就行了吧。</p>
<p>就这么简单。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">bitset&lt;1005&gt; fyn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lt</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125; <span class="comment">//找到第一个 1 的位置 </span></span><br><span class="line"><span class="type">int</span> lbt[<span class="number">1030</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1030</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v1,v2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	fyn.<span class="built_in">reset</span>();</span><br><span class="line">	fyn[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;x;x-=<span class="built_in">lt</span>(x))&#123; <span class="comment">//找出每个选入的点并计入 </span></span><br><span class="line">		sum+=a[lbt[<span class="built_in">lt</span>(x)]];</span><br><span class="line">		fyn|=(fyn&lt;&lt;a[lbt[<span class="built_in">lt</span>(x)]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;v1+v2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=v1;i&gt;=<span class="number">0</span>;--i)&#123; <span class="comment">//不仅要求装得下，还要分成两份后两个车都装得下 </span></span><br><span class="line">		<span class="keyword">if</span>(fyn[i] &amp;&amp; sum-i&lt;=v2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum-i&gt;v2)<span class="keyword">break</span>;<span class="comment">//小剪枝 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">1030</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1ll</span>&lt;&lt;n);++i)&#123; <span class="comment">//枚举 n 位中可以用到的状态并记录 </span></span><br><span class="line">		dp[i]=INF;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(i))</span><br><span class="line">			ans[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1030</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;lbt[i<span class="number">-1</span>]+<span class="number">1</span>)==i)lbt[i]=lbt[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> lbt[i]=lbt[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) cin&gt;&gt;a[i];</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">slove</span>();</span><br><span class="line">		dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//dp[i]表示状态为 i 时的最小次数 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[j]==INF)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>((j&amp;ans[i])==<span class="number">0</span>)&#123; </span><br><span class="line">				<span class="comment">//要求两个状态不能重合，如果重合就相当于同时选了两个同一个编号的物品，不符合题意 </span></span><br><span class="line">					dp[j|ans[i]]=<span class="built_in">min</span>(dp[j]+<span class="number">1</span>,dp[j|ans[i]]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Scenario #&quot;</span>&lt;&lt;++cnt&lt;&lt;<span class="string">&quot;:\n&quot;</span>&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;endl;;</span><br><span class="line">		<span class="keyword">if</span>(T)<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-2-POJ-2411"><a href="#例题-2-POJ-2411" class="headerlink" title="例题 2 POJ 2411"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-2411">例题 2 POJ 2411</a></h2><h2 id="简述题意-1"><a href="#简述题意-1" class="headerlink" title="简述题意:"></a>简述题意:</h2><p>正方形和长方形着迷荷兰著名画家彼得·蒙德里安。一天晚上，他做了个梦，想在厕纸上画出来，他梦中用小长方形以不同的方式填充一个大长方形，而每个小长方形的大小是2x1。</p>
<p>他是在这个材料中的专家，他一眼就看出他需要一台计算机来计算填充长方形的方法，这些长方形的尺寸也是整数值。帮助他，使他的梦不会变成一场噩梦！</p>
<p><img src="https://vj.csgrandeur.cn/91cd2a849209448a71d50fa577e5d5ed?v=1588013082" alt="none"></p>
<p>输入</p>
<p>输入包含多个测试案例。每个测试案例是由两个整数：高度$H$和$W$的大矩形的宽度，且$1 \le  H,W \le11$。当输入$H = W = 0$时表示终止</p>
<p>输出</p>
<p>对于每个测试用例，输出不同的填充方法数量</p>
<p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 11</span><br><span class="line">4 11</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">144</span><br><span class="line">51205</span><br></pre></td></tr></table></figure></p>
<p>提示：打表的耗子为汁，好好反省。</p>
<p>好了大家都看到提示了，我也不多说什么了，推荐打表水过去的每日四个人参补补身子。</p>
<p>显然看到范围$1 \le  H,W \le11$不用多说，又是跪着求状压了。</p>
<p>先考虑 dp 的状态。</p>
<p>既然想到了状压，那必然是压一行或是一列。</p>
<p>这里我选择的是压一行的状态。</p>
<p>很显然对于每个小方块来说我们有两种状态，一种横放一种竖放。</p>
<p>前一种不会影响上下，后一种会影响上下，也就是我们的 dp 会有限制。</p>
<p>设状态以下：</p>
<ol>
<li>如果是横着放，就在两格上放两个 0。</li>
<li>如果竖着放，就在上面一行放 1 ，x下面一行放 0。</li>
</ol>
<p>首先考虑每一行的状态的不合法情况。</p>
<p>很容易发现最后一行全部是 0 。不懂的自己面壁思考一下定义。</p>
<p>然后就是对于一行而言，首先当前行不能与上面一行有 1 的冲突，所以 &amp; 起来的答案必须得是 = 0 的。</p>
<p>其次，我们把上面的 1 全部延续下来后，剩下的 0 就都是横着放所导致的状态了，所以我们判断连续 0 的个数必须不为奇数就行了。</p>
<p>对于每个状态可以进行一个预处理储存是否合法就行了。</p>
<p>然后考虑竖着的 dp 。</p>
<p>很显然限制条件就是上面的了，最后的值就是上一行符合状态的方案数的总和了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> fyn[<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="comment">//预处理出 不合法的状态 </span></span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="built_in">memset</span>(fyn,<span class="number">0</span>,<span class="keyword">sizeof</span> fyn);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123; <span class="comment">//判断连续0的个数 </span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(cnt%<span class="number">2</span>)&#123;</span><br><span class="line">					fyn[i]=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> ++cnt;</span><br><span class="line">			<span class="keyword">if</span>(j==n<span class="number">-1</span>)&#123;</span><br><span class="line">				fyn[i]=cnt%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n &amp;&amp; !m)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">init</span>(m);</span><br><span class="line">		<span class="type">int</span> FYN=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=FYN;++j)&#123;</span><br><span class="line">				dp[i][j]=<span class="number">0</span>; </span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=FYN;++k)&#123;</span><br><span class="line">					<span class="keyword">if</span>((j&amp;k)==<span class="number">0</span> &amp;&amp; fyn[j|k])&#123; <span class="comment">//如果 1 没有冲突并且符合条件 </span></span><br><span class="line">						dp[i][j]+=dp[i<span class="number">-1</span>][k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;endl;<span class="comment">//最后一行必定全是 0 </span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-3-POJ-3254"><a href="#例题-3-POJ-3254" class="headerlink" title="例题 3 POJ 3254 "></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-3254">例题 3 POJ 3254 </a></h2><h2 id="简述题意-2"><a href="#简述题意-2" class="headerlink" title="简述题意:"></a>简述题意:</h2><p>农场主John新买新牧场，这块牧场被划分成 M 行 N 列$(1 \le M \le 12; 1 \le N \le 12)$，每一格都是一块正方形的土地。John 打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p>
<p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是 John 不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p>
<p>John 想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p>
<p>输入</p>
<p>第一行：两个整数M和N，用空格隔开。</p>
<p>第 2 到第 M+1 行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第 i+1 行描述了第i行的土地，所有整数均为 0 或 1 ，是 1 的话，表示这块土地足够肥沃， 0 则表示这块土地不适合种草。</p>
<p>Output</p>
<p>一个整数，即牧场分配总方案数除以$10^9$的余数。</p>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure>
<p>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>和上面一题很像，一样是压缩一行，预处理合法状态。</p>
<p>不想写了(因为在摸鱼。</p>
<p>所以直接看代码吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> fyn[<span class="number">15</span>],st[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">15</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> m,n,mx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123; <span class="comment">//找到 符合状态 </span></span><br><span class="line">		<span class="keyword">if</span>((i&amp;(i&lt;&lt;<span class="number">1</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">			st[++mx]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(fyn,<span class="number">0</span>,<span class="built_in">sizeof</span>(fyn));</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">			<span class="type">int</span> tem;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">				cin&gt;&gt;tem;</span><br><span class="line">				<span class="keyword">if</span>(tem==<span class="number">0</span>)</span><br><span class="line">					fyn[i]|=(<span class="number">1</span>&lt;&lt;(n-j));<span class="comment">//枚举第i行不符合状态 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">			<span class="keyword">if</span>((st[i]&amp;fyn[<span class="number">1</span>])==<span class="number">0</span>)dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;++i) <span class="comment">//枚举行 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=mx;++k)</span><br><span class="line">				<span class="keyword">if</span>((st[k]&amp;fyn[i])==<span class="number">0</span>)&#123; <span class="comment">//判断状态是否存在 </span></span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=mx;++j)</span><br><span class="line">						<span class="keyword">if</span>(((st[j]&amp;fyn[i<span class="number">-1</span>])==<span class="number">0</span>)&amp;&amp;((st[j]&amp;st[k])==<span class="number">0</span>)) <span class="comment">//不可以上下相邻 </span></span><br><span class="line">							dp[i][k]=(dp[i][k]+dp[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)ans=(ans+dp[m][i])%mod;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-4-HDU-6321"><a href="#例题-4-HDU-6321" class="headerlink" title="例题 4 HDU 6321"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-6321">例题 4 HDU 6321</a></h2><p>给你$n$个点，$m$个操作，每种操作要么加一条边要么减一条边，紧接着询问当前选出 1 条无公共端点的边，2 条无公共端点的边，3 条….. $\frac{n}{2}$  条无公共端点边时分别有多少种不同的选择。$(n\le 10)$</p>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1		</span><br><span class="line">4 8	</span><br><span class="line">+ 1 2</span><br><span class="line">+ 3 4</span><br><span class="line">+ 1 3</span><br><span class="line">+ 2 4</span><br><span class="line">- 1 2</span><br><span class="line">- 3 4</span><br><span class="line">+ 1 2</span><br><span class="line">+ 3 4</span><br></pre></td></tr></table></figure>
<p>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line">3 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure></p>
<p>状压。</p>
<p>把十个点状压到一个int里面，0表示没有匹配，1表示已匹配。<br>加入 / 删除一条边$(u,v)$时，这条边增加 / 减少的匹配方案数可以通过删除 $u,v$ 之后其他点的匹配方案数得到。</p>
<p>所以转移的时候从补集转移过来求和就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">2005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> fyn[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123; <span class="comment">//预处理2的幂次 </span></span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);++i)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>,fyn=i;</span><br><span class="line">        <span class="keyword">while</span>(fyn)</span><br><span class="line">            cnt+=(fyn&amp;<span class="number">1</span>),</span><br><span class="line">            fyn&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        fyn[i]=(cnt&amp;<span class="number">1</span>)?<span class="number">0</span>:(cnt&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> wm=pre[n];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            string op;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            u--;</span><br><span class="line">            v--;</span><br><span class="line">            <span class="type">int</span> fyn=pre[u]|pre[v];<span class="comment">//求两个的或，方便后面的补集 </span></span><br><span class="line">            <span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                s=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wm;++i)</span><br><span class="line">                <span class="keyword">if</span>((fyn&amp;i)==<span class="number">0</span>)</span><br><span class="line">                    dp[fyn|i]=(dp[fyn|i]+(s*dp[i])+mod)%mod;</span><br><span class="line">            <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wm;++i)</span><br><span class="line">                ans[fyn[i]]=(ans[fyn[i]]+dp[i])%mod;</span><br><span class="line">            <span class="type">int</span> n2=(n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)&#123;</span><br><span class="line">                cout&lt;&lt;ans[i];</span><br><span class="line">				<span class="keyword">if</span>(i==n2)<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">				<span class="keyword">else</span> cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-5-HDU-3001"><a href="#例题-5-HDU-3001" class="headerlink" title="例题 5 HDU 3001"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-3001">例题 5 HDU 3001</a></h2><p>题意：</p>
<p>给你一个<strong>无向图</strong>，从一个点到另一个点有路，需要花费。起点是任意的，要求每个点最多走两次，把所有的点遍历完一遍，费用最小。</p>
<hr>
<p>输入</p>
<p>$n(1\le n\le 10)$ 和 $m$,接下来 m 行每行 3 个数 $a,b,c(a,b\le n) $，表示 a 与 b 之间有边的值为 c 。</p>
<hr>
<p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2 100</span><br><span class="line">3 2</span><br><span class="line">1 2 40</span><br><span class="line">2 3 50</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 10</span><br></pre></td></tr></table></figure><br>output</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">90</span><br><span class="line">7 </span><br></pre></td></tr></table></figure></h2><p>三进制压缩，把每个点访问次数压缩成 int ,然后就是板子 dp 了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">60000</span>];</span><br><span class="line"><span class="type">int</span> init[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fyn</span>&#123; <span class="comment">// 三进制转换 </span></span><br><span class="line">	<span class="type">int</span> cnt[<span class="number">12</span>];</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="title">fyn</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">		res=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">	        cnt[i]=num%<span class="number">3</span>;</span><br><span class="line">	        num/=<span class="number">3</span>;</span><br><span class="line">	        res+=(cnt[i]?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">        init[i]=init[i<span class="number">-1</span>]+(init[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>);<span class="comment">//预处理3的幂次 </span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="number">-1</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            a--;b--;</span><br><span class="line">            <span class="keyword">if</span>(v[a][b]==<span class="number">-1</span>) v[a][b]=v[b][a]=c;</span><br><span class="line">            <span class="keyword">else</span> v[a][b]=v[b][a]=<span class="built_in">min</span>(c,v[a][b]);<span class="comment">//存边 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st=<span class="number">1</span>;st&lt;init[n];++st)&#123;</span><br><span class="line">            fyn fy=st;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">                <span class="keyword">if</span>(fy.cnt[i])&#123; <span class="comment">// 如果当前点存在状态中 </span></span><br><span class="line">                    <span class="keyword">if</span>(fy.res==<span class="number">1</span>)</span><br><span class="line">                        dp[i][st]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][st]==<span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(fy.res==n)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">                            ans=dp[i][st];</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            ans=<span class="built_in">min</span>(ans,dp[i][st]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="comment">//枚举转移过来的点 </span></span><br><span class="line">                        <span class="keyword">if</span>(i!=j&amp;&amp;fy.cnt[j]!=<span class="number">2</span>&amp;&amp;v[i][j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                            <span class="type">int</span> nxt=st+init[j];</span><br><span class="line">                            <span class="keyword">if</span>(dp[j][nxt]==<span class="number">-1</span>)</span><br><span class="line">                                dp[j][nxt]=dp[i][st]+v[i][j];</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                dp[j][nxt]=<span class="built_in">min</span>(dp[i][st]+v[i][j],dp[j][nxt]); </span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-6-POJ-3311"><a href="#例题-6-POJ-3311" class="headerlink" title="例题 6 POJ 3311"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-3311">例题 6 POJ 3311</a></h2><p>给你一个有$n+1(1\le n\le 10)$个点的有向完全图，用矩阵的形式给出任意两个不同点之间的距离。（其中从 i 到 j 的距离<strong>不一定等于</strong>从 j 到 i 的距离）现在要你求出从 0 号点出发，走过 1 到 n 号点至少一次，然后再回到0号点所花的最小时间。</p>
<p>输入：包含多组实例。每个实例第一个为n，然后是n+1行矩阵，每行矩阵有 n+1 个数字，第 i 行第 j 个数字表示从 i-1 到 j-1 号点的距离。当输入 n=0 时表示输入结束。</p>
<p>输出：最小距离。</p>
<p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 10 10</span><br><span class="line">1 0 1 2</span><br><span class="line">10 1 0 10</span><br><span class="line">10 2 10 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>可以发现求最短距离，我们可以直接跑最短路。</p>
<p>定义 $dp_{i,j}$ 表示第 i 个点时候状态为 j 的最小距离，其中 j 记得是访问过哪些点。</p>
<p>然后我们可以先跑最短路求出一个点到另一个点的最短距离，然后直接枚举状态上手 dp。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">13</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fyn</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		++cnt;</span><br><span class="line">		x-=x&amp;(-x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">				cin&gt;&gt;a[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)&#123;</span><br><span class="line">					<span class="keyword">if</span>(k==i || k==j) <span class="keyword">continue</span>;</span><br><span class="line">					a[i][j]=<span class="built_in">min</span>(a[i][j],a[i][k]+a[k][j]);<span class="comment">//跑最短路 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0x7fffffff</span>; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123; <span class="comment">//dp </span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">				dp[j][i]=ans;</span><br><span class="line">				<span class="keyword">if</span>(i==(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>))&#123;</span><br><span class="line">					dp[j][i]=a[<span class="number">0</span>][j];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>))&#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)&#123;</span><br><span class="line">							<span class="keyword">if</span>(j!=k &amp;&amp; (i&amp;(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)))&#123;</span><br><span class="line">								dp[j][i]=<span class="built_in">min</span>(dp[j][i],dp[k][i^(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)]+a[k][j]); <span class="comment">//这么后面了，该学会不看注释了。</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,dp[i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]+a[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-7-HDU-3237"><a href="#例题-7-HDU-3237" class="headerlink" title="例题 7 HDU 3237 "></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-3237">例题 7 HDU 3237 </a></h2><p>一个书架有 n 本书，每本书的高度介于25和32之间，n 本书中高度连续相同的算一段，一般来说 n 本书会有很多段，现在最多可以取出 k 本书再插进原书架中，问这些书最少有几段？</p>
<p>$1\le n,k \le 100$</p>
<p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">25 25 32 32 25</span><br><span class="line">5 1</span><br><span class="line">25 26 25 26 25</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p>
<p>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 2</span><br><span class="line"></span><br><span class="line">Case 2: 3</span><br></pre></td></tr></table></figure></p>
<p>可以发现直接压书本 n 是不行的，而且状态似乎也很难搞定。</p>
<p>所以我们可以状压书本的高度。</p>
<p>利用压缩书本高度来判断留下或抽走。</p>
<p>最后利用状态判断插回去还可以判断一下插进去需不需要新增段罢了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define MIN 110</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">11451451</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m,ht[<span class="number">110</span>],ans,coun[<span class="number">1</span>&lt;&lt;<span class="number">8</span>]; <span class="comment">//coun[i]表示状态i中1的个数</span></span><br><span class="line">	<span class="type">int</span> fyn,dp[<span class="number">2</span>][<span class="number">110</span>][<span class="number">1</span>&lt;&lt;<span class="number">8</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="comment">//dp[0/1][j][k][s]表示到第i行取走j本书剩下的状态数为k最后一本书高度是s时最少连续段数 </span></span><br><span class="line">	<span class="comment">//滚动数组 </span></span><br><span class="line">	<span class="type">int</span> cas;</span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 </span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">8</span>);++i)&#123; <span class="comment">//预处理每个状态 1 的个数 </span></span><br><span class="line">	        <span class="type">int</span> fyn=i;</span><br><span class="line">			<span class="keyword">while</span>(fyn)</span><br><span class="line">	            ++coun[i],fyn-=fyn&amp;(-fyn);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="built_in">init</span>();</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n &amp;&amp; m) &#123;</span><br><span class="line">	 </span><br><span class="line">	        <span class="type">int</span> mx=fyn=<span class="number">0</span>;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">	            cin&gt;&gt;ht[i];</span><br><span class="line">	            ht[i]-=<span class="number">25</span>;<span class="comment">//这算离散化吗，这算吧，那就是吧 </span></span><br><span class="line">	            <span class="keyword">if</span>(ht[i]&gt;mx) mx=ht[i]; <span class="comment">//记录最大值方便dp </span></span><br><span class="line">	            fyn|=(<span class="number">1</span>&lt;&lt;ht[i]);</span><br><span class="line">	        &#125;</span><br><span class="line">	        ++mx;</span><br><span class="line">	        </span><br><span class="line">			<span class="type">int</span> tot=(<span class="number">1</span>&lt;&lt;mx);</span><br><span class="line">	        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;++j)</span><br><span class="line">	            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;tot;++k)</span><br><span class="line">	                <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;=mx;++s)</span><br><span class="line">	                    dp[<span class="number">1</span>][j][k][s]=INF;<span class="comment">//初始化 </span></span><br><span class="line">	                    </span><br><span class="line">	       dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>&lt;&lt;ht[<span class="number">1</span>]][ht[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">	       dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][mx]=<span class="number">0</span>;<span class="comment">//留下一本的高度为 mx 的答案绝对不存在(因为有更小更优)，所以掏出来转移 </span></span><br><span class="line">	       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		           <span class="type">int</span> pre=<span class="number">1</span>^(i&amp;<span class="number">1</span>);</span><br><span class="line">		           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;++j)</span><br><span class="line">		                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;tot;++k)</span><br><span class="line">		                    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;=mx;++s)</span><br><span class="line">		                        dp[i&amp;<span class="number">1</span>][j][k][s]=INF;</span><br><span class="line">		 </span><br><span class="line">		           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m &amp;&amp; j&lt;i;++j)</span><br><span class="line">		               <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;tot;++k)</span><br><span class="line">		                   <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;=mx;++s)&#123;</span><br><span class="line">		                       <span class="keyword">if</span>(dp[pre][j][k][s]==INF) <span class="keyword">continue</span>;</span><br><span class="line">		                       <span class="type">int</span> now=k|(<span class="number">1</span>&lt;&lt;ht[i]);     </span><br><span class="line">		                        <span class="keyword">if</span>(j&lt;m)                                      </span><br><span class="line">		                            dp[i&amp;<span class="number">1</span>][j+<span class="number">1</span>][k][s]=<span class="built_in">min</span>(dp[i&amp;<span class="number">1</span>][j+<span class="number">1</span>][k][s],dp[pre][j][k][s]); <span class="comment">//如果还可以取，就取咯 </span></span><br><span class="line">		                        <span class="keyword">if</span>(s==ht[i])                               </span><br><span class="line">		                            dp[i&amp;<span class="number">1</span>][j][k][ht[i]]=<span class="built_in">min</span>(dp[i&amp;<span class="number">1</span>][j][k][s],dp[pre][j][k][s]);<span class="comment">//如果高度最后一样，就直接合并，因为没有贡献啊 </span></span><br><span class="line">		                        <span class="keyword">else</span>                                            </span><br><span class="line">		                            dp[i&amp;<span class="number">1</span>][j][now][ht[i]]=<span class="built_in">min</span>(dp[i&amp;<span class="number">1</span>][j][now][ht[i]],dp[pre][j][k][s]+<span class="number">1</span>);<span class="comment">//高度不一样说明无法合成一段，要增加一个新的段</span></span><br><span class="line">		        &#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	        <span class="type">int</span> cur=n&amp;<span class="number">1</span>,ans=n;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;++j)</span><br><span class="line">	            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;tot;++k)</span><br><span class="line">	                <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;mx;++s) </span><br><span class="line">	                    <span class="keyword">if</span> (dp[cur][j][k][s]!=INF)&#123; </span><br><span class="line">	                    <span class="type">int</span> st=fyn^k; <span class="comment">//补集就是剩下的书了 </span></span><br><span class="line">	                    ans=<span class="built_in">min</span>(ans,coun[st]+dp[cur][j][k][s]); <span class="comment">//剩下的书加上抽走的书的段 </span></span><br><span class="line">	                &#125;</span><br><span class="line">	 </span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++cas&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-7-CodeChef-MAXOR"><a href="#例题-7-CodeChef-MAXOR" class="headerlink" title="例题 7 CodeChef MAXOR  "></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/CodeChef-MAXOR">例题 7 CodeChef MAXOR  </a></h2><p>给你 N 个数，要求求出符合条件的 $i,j[a_i | a_j \le \max(a_i,a_j)]$</p>
<p>多组数据</p>
<p>$T(1\le T \le 20)$，$1 \le N \le 106 $,$<br>0 \le a_i \le 106$,$1 ≤ \sum n ≤ 106$</p>
<p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>传说中的高维前缀和$(SOSDP)$。</p>
<p>好吧刚听到的时候我想喊 SOS 的，毕竟DP带前缀的都不是什么好东西(DDP?)。</p>
<p>然后我发现我 SOS 白喊了。</p>
<p>这玩意似乎就是正常 dp 。</p>
<p>会发现题意是在放屁，事实上只有等于的这种可能性。</p>
<p>所以直接dp吧。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> fyn[N],fyn1[N];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(fyn,<span class="number">0</span>,<span class="keyword">sizeof</span> fyn);</span><br><span class="line">		<span class="built_in">memset</span>(fyn1,<span class="number">0</span>,<span class="keyword">sizeof</span> fyn1);</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			fyn[x]=++fyn1[x];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">					fyn[j]+=fyn[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//传说中的高维前缀和</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fyn[i])&#123;</span><br><span class="line">				ans+=fyn1[i]*(fyn1[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">				ans+=(fyn[i]-fyn1[i])*fyn1[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2022/12/23/论我在学校阳了以后还要写作业/" data-toggle="tooltip" data-placement="top"
                           title="论我在学校阳了以后还要写作业">&larr; 上一篇文章</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2022/12/09/ZOJ-3682-题解/" data-toggle="tooltip" data-placement="top"
                           title="ZOJ 3682 题解">下一篇文章 &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1-POJ-2923"><span class="toc-text">例题 1 POJ 2923</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E9%A2%98%E6%84%8F"><span class="toc-text">简述题意:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2-POJ-2411"><span class="toc-text">例题 2 POJ 2411</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E9%A2%98%E6%84%8F-1"><span class="toc-text">简述题意:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3-POJ-3254"><span class="toc-text">例题 3 POJ 3254 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E9%A2%98%E6%84%8F-2"><span class="toc-text">简述题意:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4-HDU-6321"><span class="toc-text">例题 4 HDU 6321</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5-HDU-3001"><span class="toc-text">例题 5 HDU 3001</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">100907 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6-POJ-3311"><span class="toc-text">例题 6 POJ 3311</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7-HDU-3237"><span class="toc-text">例题 7 HDU 3237 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7-CodeChef-MAXOR"><span class="toc-text">例题 7 CodeChef MAXOR  </span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/notes"
                           title="notes">notes</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                

                
                    <li>
                        <a target="_blank" href="https://www.luogu.com.cn/user/388414">
                                <i>洛谷</i>
                        </a>
                    </li>
                    <br>
                

                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; y233 2022
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme Anisina
                    <br>
                    Theme chagned by <a target="_blank" rel="noopener" href="https://zhizionenuo.github.io/">y233&&zhizionenuo</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/blog.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span id="busuanzi_container_site_pv"" style="font-size: 12px;display:none;">总访问量：<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style="font-size: 12px;display:none;">总访客：<span id="busuanzi_value_site_uv"></span>人</span>


<!--wechat title img-->
<img class="wechat-title-img" src="null">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
